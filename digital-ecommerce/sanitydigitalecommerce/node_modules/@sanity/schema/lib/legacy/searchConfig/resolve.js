"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resolveSearchConfig;
exports.deriveFromPreview = deriveFromPreview;
exports.getCachedStringFieldPaths = getCachedStringFieldPaths;
exports.pathCountSymbol = void 0;
exports.resolveSearchConfigForBaseFieldPaths = resolveSearchConfigForBaseFieldPaths;
exports.stringFieldsSymbol = void 0;
var _uniqBy2 = _interopRequireDefault(require("lodash/uniqBy"));
var _types = require("@sanity/types");
var _normalize = require("./normalize");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var stringFieldsSymbol = Symbol('__cachedStringFields');
exports.stringFieldsSymbol = stringFieldsSymbol;
var pathCountSymbol = Symbol('__cachedPathCount');

// Max number of levels to traverse per root-level object
// eslint-disable-next-line no-process-env
exports.pathCountSymbol = pathCountSymbol;
var SEARCH_DEPTH_LIMIT = Number(process.env.SANITY_STUDIO_UNSTABLE_SEARCH_DEPTH_LIMIT) || 15;

// Max number of search paths to extract per root-level object
// eslint-disable-next-line no-process-env
var SEARCH_PATH_LIMIT = Number(process.env.SANITY_STUDIO_UNSTABLE_SEARCH_PATH_LIMIT) || 500;
var BASE_WEIGHTS = [{
  weight: 1,
  path: ['_id']
}, {
  weight: 1,
  path: ['_type']
}];
var PREVIEW_FIELD_WEIGHT_MAP = {
  title: 10,
  subtitle: 5,
  description: 1.5
};
var PORTABLE_TEXT_FIELDS = ['style', 'list'];
var isPortableTextArray = type => (0, _types.isArraySchemaType)(type) && Array.isArray(type.of) && type.of.some(_types.isBlockSchemaType);
// eslint-disable-next-line max-params
function reduceType(rootType, type, reducer, acc) {
  var path = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var maxDepth = arguments.length > 5 ? arguments[5] : undefined;
  if (maxDepth < 0 || rootType[pathCountSymbol] < 0) {
    return acc;
  }
  var accumulator = reducer(acc, type, path);
  if ((0, _types.isArraySchemaType)(type) && Array.isArray(type.of)) {
    return reduceArray(rootType, type, reducer, accumulator, path, maxDepth);
  }
  if ((0, _types.isObjectSchemaType)(type) && Array.isArray(type.fields) && !(0, _types.isReferenceSchemaType)(type)) {
    return reduceObject(rootType, type, reducer, accumulator, path, maxDepth);
  }

  // Store and mutate count on the root type to handle circular recursive structures
  rootType[pathCountSymbol] -= 1;
  return accumulator;
}

// eslint-disable-next-line max-params
function reduceArray(rootType, arrayType, reducer, accumulator, path, maxDepth) {
  return arrayType.of.reduce((acc, ofType) => reduceType(rootType, ofType, reducer, acc, path, maxDepth - 1), accumulator);
}

// eslint-disable-next-line max-params
function reduceObject(rootType, objectType, reducer, accumulator, path, maxDepth) {
  return Array.from(objectType.fields).sort((a, b) => {
    // Object fields with these types will be pushed to the end
    var sortTypes = ['array', 'object'];
    var aIsObjectOrArray = sortTypes.includes(a.type.jsonType);
    var bIsObjectOrArray = sortTypes.includes(b.type.jsonType);

    // Sort by name when either both (or neither) comparators are objects and/or arrays
    if (aIsObjectOrArray) {
      return bIsObjectOrArray ? a.name.localeCompare(b.name) : 1;
    }
    return bIsObjectOrArray ? -1 : a.name.localeCompare(b.name);
  }).reduce((acc, field) => {
    // Don't include styles and list types as searchable paths for portable text blocks
    if ((0, _types.isBlockSchemaType)(objectType) && PORTABLE_TEXT_FIELDS.includes(field.name)) {
      return acc;
    }
    var segment = [field.name].concat((0, _types.isArraySchemaType)(field.type) ? [[]] : []);
    return reduceType(rootType, field.type, reducer, acc, path.concat(segment), maxDepth - 1);
  }, accumulator);
}

/**
 * @internal
 */
function deriveFromPreview(type) {
  var _type$preview;
  var select = type === null || type === void 0 || (_type$preview = type.preview) === null || _type$preview === void 0 ? void 0 : _type$preview.select;
  if (!select) {
    return [];
  }
  return Object.keys(select).filter(fieldName => fieldName in PREVIEW_FIELD_WEIGHT_MAP).map(fieldName => ({
    weight: PREVIEW_FIELD_WEIGHT_MAP[fieldName],
    path: select[fieldName].split('.').map(_normalize.stringsToNumbers)
  }));
}
function getCachedStringFieldPaths(type, maxDepth, maxSearchPaths) {
  type[pathCountSymbol] = maxSearchPaths;
  if (!type[stringFieldsSymbol]) {
    type[stringFieldsSymbol] = (0, _uniqBy2.default)([...BASE_WEIGHTS, ...deriveFromPreview(type), ...getFieldSearchPaths(type, maxDepth)], spec => spec.path.join('.')).slice(0, maxSearchPaths);
  }
  return type[stringFieldsSymbol];
}
function getCachedBaseFieldPaths(type) {
  if (!type[stringFieldsSymbol]) {
    type[stringFieldsSymbol] = (0, _uniqBy2.default)([...BASE_WEIGHTS, ...deriveFromPreview(type)], spec => spec.path.join('.'));
  }
  return type[stringFieldsSymbol];
}
function getFieldSearchPaths(type, maxDepth) {
  var reducer = (acc, childType, path) => {
    if (childType.jsonType === 'string') {
      return [...acc, {
        path,
        weight: 1
      }];
    }
    if (isPortableTextArray(childType)) {
      return [...acc, {
        mapWith: 'pt::text',
        path,
        weight: 1
      }];
    }
    return acc;
  };
  return reduceType(type, type, reducer, [], [], maxDepth);
}
function resolveSearchConfigForBaseFieldPaths(type) {
  return getCachedBaseFieldPaths(type);
}
function resolveSearchConfig(type) {
  return getCachedStringFieldPaths(type, SEARCH_DEPTH_LIMIT, SEARCH_PATH_LIMIT);
}